#[cfg(test)]
mod tests {
    use super::{JSONPointer, JSONValue};

    #[test]
    fn json_pointer_parse() {
        for (input, output) in vec![
            ("hello", JSONPointer::String("hello".to_string())),
            ("9a", JSONPointer::String("9a".to_string())),
            ("a9", JSONPointer::String("a9".to_string())),
            ("*a", JSONPointer::String("*a".to_string())),
            (
                "/hello/world",
                JSONPointer::Path(vec![
                    JSONPointer::String("hello".to_string()),
                    JSONPointer::String("world".to_string()),
                ]),
            ),
            ("*", JSONPointer::Wildcard),
            (
                "/hello/*",
                JSONPointer::Path(vec![
                    JSONPointer::String("hello".to_string()),
                    JSONPointer::Wildcard,
                ]),
            ),
            ("1234", JSONPointer::Number(1234)),
            (
                "/hello/1234",
                JSONPointer::Path(vec![
                    JSONPointer::String("hello".to_string()),
                    JSONPointer::Number(1234),
                ]),
            ),
            ("~0~1", JSONPointer::String("~/".to_string())),
            (
                "/hello/~0~1",
                JSONPointer::Path(vec![
                    JSONPointer::String("hello".to_string()),
                    JSONPointer::String("~/".to_string()),
                ]),
            ),
            (
                "/hello/world/*/99",
                JSONPointer::Path(vec![
                    JSONPointer::String("hello".to_string()),
                    JSONPointer::String("world".to_string()),
                    JSONPointer::Wildcard,
                    JSONPointer::Number(99),
                ]),
            ),
            ("/", JSONPointer::String("".to_string())),
            (
                "///",
                JSONPointer::Path(vec![
                    JSONPointer::String("".to_string()),
                    JSONPointer::String("".to_string()),
                ]),
            ),
            ("", JSONPointer::Root),
        ] {
            assert_eq!(JSONPointer::parse(input), Some(output), "{}", input);
        }
    }

    #[test]
    fn json_pointer_eval() {
        let input = serde_json::from_slice::<JSONValue>(
            br#"{
            "foo": ["bar", "baz"],
            "": 0,
            "a/b": 1,
            "c%d": 2,
            "e^f": 3,
            "g|h": 4,
            "i\\j": 5,
            "k\"l": 6,
            " ": 7,
            "m~n": 8
         }"#,
        )
        .unwrap();

        for (pointer, expected_result) in [
            ("", input.clone()),
            (
                "/foo",
                vec!["bar".to_string().into(), "baz".to_string().into()].into(),
            ),
            ("/foo/0", "bar".to_string().into()),
            ("/", 0u64.into()),
            ("/a~1b", 1u64.into()),
            ("/c%d", 2u64.into()),
            ("/e^f", 3u64.into()),
            ("/g|h", 4u64.into()),
            ("/i\\j", 5u64.into()),
            ("/k\"l", 6u64.into()),
            ("/ ", 7u64.into()),
            ("/m~0n", 8u64.into()),
        ] {
            //assert_eq!(input.eval(pointer).unwrap(), expected_result, "{}", pointer);
        }

        assert_eq!(
            serde_json::from_slice::<JSONValue>(
                br#"{
                "accountId": "A1",
                "queryState": "abcdefg",
                "canCalculateChanges": true,
                "position": 0,
                "total": 101,
                "ids": [ "msg1023", "msg223", "msg110", "msg93", "msg91",
                    "msg38", "msg36", "msg33", "msg11", "msg1" ]
            }"#
            )
            .unwrap()
            .eval("/ids")
            .unwrap(),
            serde_json::from_slice::<JSONValue>(
                br#"[ "msg1023", "msg223", "msg110", "msg93", "msg91",
        "msg38", "msg36", "msg33", "msg11", "msg1" ]"#
            )
            .unwrap()
        );

        assert_eq!(
            serde_json::from_slice::<JSONValue>(
                br#"{
            "accountId": "A1",
            "state": "123456",
            "list": [{
                "id": "msg1023",
                "threadId": "trd194"
            }, {
                "id": "msg223",
                "threadId": "trd114"
            }],
            "notFound": []
        }"#
            )
            .unwrap()
            .eval("/list/*/threadId")
            .unwrap(),
            serde_json::from_slice::<JSONValue>(br#"[ "trd194", "trd114" ]"#).unwrap()
        );

        assert_eq!(
            serde_json::from_slice::<JSONValue>(
                br#"{
            "accountId": "A1",
            "state": "123456",
            "list": [{
                "id": "trd194",
                "emailIds": [ "msg1020", "msg1021", "msg1023" ]
            }, {
                "id": "trd114",
                "emailIds": [ "msg201", "msg223" ]
            }],
            "notFound": []
        }"#
            )
            .unwrap()
            .eval("/list/*/emailIds")
            .unwrap(),
            serde_json::from_slice::<JSONValue>(
                br#"[ "msg1020", "msg1021", "msg1023", "msg201", "msg223" ]"#
            )
            .unwrap()
        );
    }
}

/*
#[cfg(test)]
mod tests {
    use std::collections::HashMap;

    use store::config::{env_settings::EnvSettings, jmap::JMAPConfig};

    use crate::{
        protocol::{json::JSONValue, request::Request},
        MethodError,
    };

    use super::Response;

    #[test]
    fn map_sort_created_ids() {
        let request = serde_json::from_slice::<Request>(
            br##"{
                    "using": [
                        "urn:ietf:params:jmap:core",
                        "urn:ietf:params:jmap:mail"
                    ],
                    "methodCalls": [
                        [
                            "Mailbox/set",
                            {
                                "accountId": "i01",
                                "create": {
                                    "a": {
                                        "name": "Folder a",
                                        "parentId": "#b"
                                    },
                                    "b": {
                                        "name": "Folder b",
                                        "parentId": "#c"
                                    },
                                    "c": {
                                        "name": "Folder c",
                                        "parentId": "#d"
                                    },
                                    "d": {
                                        "name": "Folder d",
                                        "parentId": "#e"
                                    },
                                    "e": {
                                        "name": "Folder e",
                                        "parentId": "#f"
                                    },
                                    "f": {
                                        "name": "Folder f",
                                        "parentId": "#g"
                                    },
                                    "g": {
                                        "name": "Folder g",
                                        "parentId": null
                                    }
                                }
                            },
                            "fulltree"
                        ],
                        [
                            "Mailbox/set",
                            {
                                "accountId": "i01",
                                "create": {
                                    "a1": {
                                        "name": "Folder a1",
                                        "parentId": null
                                    },
                                    "b2": {
                                        "name": "Folder b2",
                                        "parentId": "#a1"
                                    },
                                    "c3": {
                                        "name": "Folder c3",
                                        "parentId": "#a1"
                                    },
                                    "d4": {
                                        "name": "Folder d4",
                                        "parentId": "#b2"
                                    },
                                    "e5": {
                                        "name": "Folder e5",
                                        "parentId": "#b2"
                                    },
                                    "f6": {
                                        "name": "Folder f6",
                                        "parentId": "#d4"
                                    },
                                    "g7": {
                                        "name": "Folder g7",
                                        "parentId": "#e5"
                                    }
                                }
                            },
                            "fulltree2"
                        ],
                        [
                            "Mailbox/set",
                            {
                                "accountId": "i01",
                                "create": {
                                    "z": {
                                        "name": "Folder Z",
                                        "parentId": "#x"
                                    },
                                    "y": {
                                        "name": null
                                    },
                                    "x": {
                                        "name": "Folder X"
                                    }
                                }
                            },
                            "xyz"
                        ],
                        [
                            "Mailbox/set",
                            {
                                "accountId": "i01",
                                "create": {
                                    "a": {
                                        "name": "Folder a",
                                        "parentId": "#b"
                                    },
                                    "b": {
                                        "name": "Folder b",
                                        "parentId": "#c"
                                    },
                                    "c": {
                                        "name": "Folder c",
                                        "parentId": "#d"
                                    },
                                    "d": {
                                        "name": "Folder d",
                                        "parentId": "#a"
                                    }
                                }
                            },
                            "circular"
                        ]
                    ]
                }"##,
        )
        .unwrap();

        let response = Response::new(
            1234,
            request.created_ids.unwrap_or_default(),
            request.method_calls.len(),
        );
        let config = JMAPConfig::from(&EnvSettings {
            args: HashMap::new(),
        });

        for (test_num, (name, arguments, _)) in request.method_calls.into_iter().enumerate() {
            match Invocation::parse(&name, arguments, &response, &config) {
                Ok(invocation) => {
                    assert!((0..3).contains(&test_num), "Unexpected invocation");

                    if let Method::Set(set) = invocation.call {
                        if test_num == 0 {
                            assert_eq!(
                                set.create.into_iter().map(|b| b.0).collect::<Vec<_>>(),
                                ["g", "f", "e", "d", "c", "b", "a"]
                                    .iter()
                                    .map(|i| i.to_string())
                                    .collect::<Vec<_>>()
                            );
                        } else if test_num == 1 {
                            let mut pending_ids = vec!["a1", "b2", "d4", "e5", "f6", "c3", "g7"];

                            for (id, _) in &set.create {
                                match id.as_str() {
                                    "a1" => (),
                                    "b2" | "c3" => assert!(!pending_ids.contains(&"a1")),
                                    "d4" | "e5" => assert!(!pending_ids.contains(&"b2")),
                                    "f6" => assert!(!pending_ids.contains(&"d4")),
                                    "g7" => assert!(!pending_ids.contains(&"e5")),
                                    _ => panic!("Unexpected ID"),
                                }
                                pending_ids.retain(|i| i != id);
                            }

                            if !pending_ids.is_empty() {
                                panic!(
                                    "Unexpected order: {:?}",
                                    all_ids = set
                                        .create
                                        .iter()
                                        .map(|b| b.0.to_string())
                                        .collect::<Vec<_>>()
                                );
                            }
                        } else if test_num == 2 {
                            assert_eq!(
                                set.create.into_iter().map(|b| b.0).collect::<Vec<_>>(),
                                ["x", "z", "y"]
                                    .iter()
                                    .map(|i| i.to_string())
                                    .collect::<Vec<_>>()
                            );
                        }
                    } else {
                        panic!("Expected SetRequest");
                    };
                }
                Err(err) => {
                    assert_eq!(test_num, 3);
                    assert!(matches!(err, MethodError::InvalidArguments(_)));
                }
            }
        }

        let request = serde_json::from_slice::<Request>(
            br##"{
                "using": [
                    "urn:ietf:params:jmap:core",
                    "urn:ietf:params:jmap:mail"
                ],
                "methodCalls": [
                    [
                        "Mailbox/set",
                        {
                            "accountId": "i01",
                            "create": {
                                "a": {
                                    "name": "a",
                                    "parentId": "#x"
                                },
                                "b": {
                                    "name": "b",
                                    "parentId": "#y"
                                },
                                "c": {
                                    "name": "c",
                                    "parentId": "#z"
                                }
                            }
                        },
                        "ref1"
                    ],
                    [
                        "Mailbox/set",
                        {
                            "accountId": "i01",
                            "create": {
                                "a1": {
                                    "name": "a1",
                                    "parentId": "#a"
                                },
                                "b2": {
                                    "name": "b2",
                                    "parentId": "#b"
                                },
                                "c3": {
                                    "name": "c3",
                                    "parentId": "#c"
                                }
                            }
                        },
                        "red2"
                    ]
                ],
                "createdIds": {
                    "x": "i01",
                    "y": "i02",
                    "z": "i03"
                }
            }"##,
        )
        .unwrap();

        let mut response = Response::new(
            1234,
            request.created_ids.unwrap_or_default(),
            request.method_calls.len(),
        );

        let mut invocations = request.method_calls.into_iter();
        let (name, arguments, _) = invocations.next().unwrap();
        let invocation = Invocation::parse(&name, arguments, &response, &config).unwrap();
        if let Method::Set(set) = invocation.call {
            let create: JSONValue = set.create.into_iter().collect::<HashMap<_, _>>().into();
            assert_eq!(create.eval_unwrap_string("/a/parentId"), "i01");
            assert_eq!(create.eval_unwrap_string("/b/parentId"), "i02");
            assert_eq!(create.eval_unwrap_string("/c/parentId"), "i03");
        } else {
            panic!("Expected SetRequest");
        };

        response.push_response(
            "test".to_string(),
            "test".to_string(),
            serde_json::from_slice::<JSONValue>(
                br##"{
                "created": {
                    "a": {
                        "id": "i05"
                    },
                    "b": {
                        "id": "i06"
                    },
                    "c": {
                        "id": "i07"
                    }
                }
            }"##,
            )
            .unwrap(),
            true,
        );

        let (name, arguments, _) = invocations.next().unwrap();
        let invocation = Invocation::parse(&name, arguments, &response, &config).unwrap();
        if let Method::Set(set) = invocation.call {
            let create: JSONValue = set.create.into_iter().collect::<HashMap<_, _>>().into();
            assert_eq!(create.eval_unwrap_string("/a1/parentId"), "i05");
            assert_eq!(create.eval_unwrap_string("/b2/parentId"), "i06");
            assert_eq!(create.eval_unwrap_string("/c3/parentId"), "i07");
        } else {
            panic!("Expected SetRequest");
        };
    }
}
*/
